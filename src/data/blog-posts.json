{
  "posts": [
    {
      "id": "led-poi-development",
      "title": "Building Programmable LED Poi: From Code to Flow",
      "slug": "led-poi-development", 
      "excerpt": "The journey of creating custom LED poi systems, combining Arduino programming with flow arts performance. Learn about the challenges of battery optimization, wireless control, and creating mesmerizing patterns.",
      "content": "# Building Programmable LED Poi: From Code to Flow\n\n*Published on January 15, 2024*\n\nFlow arts and technology might seem like an unlikely combination, but they've become the heart of my most rewarding projects. Today I want to share the journey of developing programmable LED poi systems that merge artistic expression with technical innovation.\n\n## The Challenge\n\nTraditional fire poi create beautiful arcs of light, but they're limited by physics. LED poi offer infinite possibilities for pattern creation, but most commercial options lack the programmability and customization I was looking for as both a performer and developer.\n\n## Technical Approach\n\n### Hardware Foundation\n- **Arduino Nano**: Compact yet powerful enough for real-time pattern processing\n- **WS2812B LED strips**: Individually addressable RGB LEDs with excellent brightness\n- **LiPo batteries**: High energy density crucial for extended performance sessions\n- **Custom PCB**: Designed for durability and weight distribution\n\n### Software Architecture\n\nThe firmware needed to handle multiple concerns:\n- **Pattern generation**: Mathematical functions for creating fluid, organic movements\n- **User interface**: Simple button controls for pattern switching during performance\n- **Power management**: Aggressive optimization for 2+ hour battery life\n- **Wireless communication**: Future-proofing for synchronized performances\n\n```cpp\nvoid generateSpiralPattern(uint8_t frame, uint8_t intensity) {\n  for(int i = 0; i < LED_COUNT; i++) {\n    float angle = (frame + i * 10) * 0.1;\n    uint8_t brightness = sin(angle) * intensity;\n    setPixel(i, HSV(angle * 180/PI, 255, brightness));\n  }\n}\n```\n\n## Lessons Learned\n\n### Power Consumption Reality\nMy first prototype lasted 20 minutes. The lesson: LED brightness scales exponentially with power draw. The final version uses dynamic brightness adjustment based on battery level and pattern complexity.\n\n### Weight Distribution Matters\nEven 50 grams in the wrong place dramatically affects flow dynamics. Multiple iterations were needed to achieve the proper balance between the LED module, battery, and counterweight.\n\n### User Experience in Motion\nDesigning controls for use while spinning requires rethinking traditional UI principles. Large buttons, tactile feedback, and muscle-memory-friendly layouts become crucial.\n\n## Results and Future\n\nThe final poi systems have been used in dozens of performances, from local festivals to larger events. The ability to synchronize patterns across multiple performers opens up entirely new choreographic possibilities.\n\nNext iterations will explore:\n- **Gyroscope integration**: Responsive patterns based on spin speed and direction\n- **Audio reactivity**: Real-time response to music\n- **Machine learning**: Pattern generation based on flow style analysis\n\n## Code and Resources\n\nThe complete source code is available on my GitHub, including PCB designs and 3D printable enclosures. I believe in open-source hardware for the flow arts community.\n\n*Have questions about LED poi development or flow arts technology? Feel free to reach out!*",
      "author": "Yuki Ainge",
      "publishedAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-01-15T10:00:00Z",
      "featured": true,
      "tags": ["electronics", "arduino", "flow-arts", "led", "programming"],
      "category": "Electronics",
      "readTime": "8 min read",
      "image": "/blog/led-poi-development.jpg"
    },
    {
      "id": "woodworking-meets-code",
      "title": "When Woodworking Meets Code: Lessons from Both Crafts",
      "slug": "woodworking-meets-code",
      "excerpt": "Exploring the surprising parallels between traditional woodworking and software development. From planning and patience to iteration and problem-solving, both crafts share fundamental principles.",
      "content": "# When Woodworking Meets Code: Lessons from Both Crafts\n\n*Published on January 22, 2024*\n\nAt first glance, cutting dovetail joints and writing functions seem worlds apart. But after years of practicing both woodworking and software development, I've discovered striking parallels that have made me better at both.\n\n## Measure Twice, Cut Once vs. Plan Before You Code\n\nWoodworking's most fundamental principle has a direct parallel in software development. In the shop, a measurement mistake can ruin hours of work and waste expensive materials. In code, poor planning leads to technical debt, refactoring nightmares, and missed deadlines.\n\n### The Planning Process\n\n**Woodworking:**\n- Detailed drawings with exact measurements\n- Material lists and cut schedules\n- Jig and fixture planning\n- Grain direction consideration\n\n**Software Development:**\n- System architecture diagrams\n- API specifications and data models\n- Testing strategies\n- Performance and scalability planning\n\n## The Grain of the Code\n\nWood has grain – the natural direction of fibers that determines strength and workability. Code has similar inherent structures. Fighting against the grain in either medium leads to problems.\n\n```javascript\n// Working with the grain - leveraging JavaScript's strengths\nconst processData = (items) => \n  items\n    .filter(item => item.active)\n    .map(item => ({ ...item, processed: true }))\n    .sort((a, b) => a.priority - b.priority)\n\n// Against the grain - forcing inappropriate patterns\nfor (let i = 0; i < items.length; i++) {\n  if (items[i].active) {\n    let newItem = {}\n    for (let key in items[i]) {\n      newItem[key] = items[i][key]\n    }\n    newItem.processed = true\n    processedItems.push(newItem)\n  }\n}\n```\n\n## Iteration and Refinement\n\nBoth crafts reward iterative improvement. In woodworking, you start with rough cuts and progressively refine to final dimensions. In code, you write working solutions and refactor for elegance and performance.\n\n### The Refinement Process\n\n1. **Rough Cut/First Draft**: Get the basic functionality working\n2. **Fine Tuning**: Optimize for performance and readability  \n3. **Finishing**: Polish the user experience and edge cases\n4. **Testing**: Verify quality and durability\n\n## Tool Mastery\n\nBoth disciplines require deep tool knowledge. A master carpenter knows exactly which chisel to use for each cut. A senior developer knows when to reach for different libraries, patterns, or languages.\n\n### Essential Tool Categories\n\n**Measuring & Planning:**\n- Woodworking: Squares, rulers, marking gauges\n- Development: Profilers, debuggers, monitoring tools\n\n**Cutting & Shaping:**\n- Woodworking: Saws, planes, chisels\n- Development: IDEs, compilers, bundlers\n\n**Assembly & Joining:**\n- Woodworking: Clamps, glue, fasteners\n- Development: Version control, CI/CD, package managers\n\n## When Things Go Wrong\n\nBoth crafts teach resilience. Wood splits, measurements are wrong, and joints don't fit. Code has bugs, requirements change, and systems fail. The key is developing problem-solving strategies that work under pressure.\n\n### Recovery Strategies\n\n- **Accept the mistake quickly** – Denial wastes time\n- **Assess the damage** – Is it fixable or do you start over?\n- **Learn the lesson** – Why did this happen?\n- **Prevent recurrence** – What process changes prevent this?\n\n## The Philosophy of Craft\n\nUltimately, both woodworking and coding are about transformation – taking raw materials (wood/requirements) and creating something useful and beautiful. The satisfaction comes not just from the end result, but from the process of careful, considered work.\n\nThe patience required to properly season wood parallels the patience needed to write maintainable code. The satisfaction of a perfect joint matches the joy of elegant algorithm. Both require attention to detail, respect for the material, and constant learning.\n\n## Practical Applications\n\nThese insights aren't just philosophical – they've made me a better developer:\n\n- **Better estimation**: Understanding the full project lifecycle\n- **Improved debugging**: Systematic problem-solving approaches  \n- **Quality focus**: Caring about the internal structure, not just external appearance\n- **Tool selection**: Choosing the right tool for each specific task\n- **Patience**: Allowing time for proper planning and testing\n\n*What unexpected connections have you found between different skills in your life? I'd love to hear about parallel lessons from other disciplines.*",
      "author": "Yuki Ainge",  
      "publishedAt": "2024-01-22T14:00:00Z",
      "updatedAt": "2024-01-22T14:00:00Z",
      "featured": true,
      "tags": ["woodworking", "programming", "craftsmanship", "philosophy", "process"],
      "category": "Philosophy",
      "readTime": "12 min read",
      "image": "/blog/woodworking-meets-code.jpg"
    },
    {
      "id": "etsy-shop-automation",
      "title": "Automating My Etsy Shop: A Developer's Approach to E-commerce",
      "slug": "etsy-shop-automation",
      "excerpt": "How I used Python scripts and APIs to automate inventory management, pricing optimization, and customer communication for my handmade goods business.",
      "content": "# Automating My Etsy Shop: A Developer's Approach to E-commerce\n\n*Published on February 5, 2024*\n\nRunning a handmade goods business while maintaining a full-time development career requires efficiency. Here's how I built automation tools to manage my Etsy shop without sacrificing the personal touch that customers value.\n\n## The Challenge\n\nManaging inventory, updating prices, responding to messages, and tracking orders manually was consuming hours each week. But I didn't want to lose the artisanal feel that makes handmade special.\n\n## Solution: Smart Automation\n\n### Inventory Management\n\nA Python script monitors my workshop inventory and automatically updates Etsy listings:\n\n```python\ndef sync_inventory():\n    workshop_inventory = load_inventory_data()\n    etsy_listings = etsy_api.get_active_listings()\n    \n    for listing in etsy_listings:\n        sku = listing['sku']\n        if sku in workshop_inventory:\n            current_qty = workshop_inventory[sku]['quantity']\n            if current_qty != listing['quantity']:\n                etsy_api.update_listing_quantity(listing['id'], current_qty)\n                log_inventory_update(sku, current_qty)\n```\n\n### Smart Pricing\n\nDynamic pricing based on material costs and demand:\n\n```python\ndef calculate_optimal_price(base_cost, demand_score, competition_price):\n    material_multiplier = 2.5  # Cover materials + time\n    demand_adjustment = 1 + (demand_score - 0.5) * 0.3\n    market_adjustment = min(competition_price * 0.95, \n                           base_cost * material_multiplier * demand_adjustment)\n    \n    return round(market_adjustment, 2)\n```\n\n### Customer Communication Templates\n\nPersonalized but efficient responses:\n\n```python\ndef generate_response(message_type, customer_name, order_details):\n    templates = {\n        'shipping_inquiry': f\"\"\"\n        Hi {customer_name},\n        \n        Thanks for your order! Your {order_details['item']} is currently \n        being crafted and will ship within {order_details['lead_time']} days.\n        \n        I'll send tracking information as soon as it's on its way.\n        \n        Best regards,\n        Yuki\n        \"\"\"\n    }\n    return templates.get(message_type, generate_custom_response(message_type))\n```\n\n## Results\n\n- **Time Saved**: 10+ hours per week\n- **Accuracy**: Zero out-of-stock orders since implementation\n- **Customer Satisfaction**: 4.9/5 star average (improved from 4.6)\n- **Revenue**: 30% increase due to optimized pricing and availability\n\n## Key Learnings\n\n### Don't Over-Automate\nSome interactions should remain personal. Custom orders, complex questions, and complaints still get personal attention.\n\n### Monitor and Adjust\nAutomation isn't \"set it and forget it.\" Regular monitoring prevents edge cases from causing problems.\n\n### Backup Plans\nAPI rate limits, service outages, and bugs happen. Always have manual processes as backup.\n\n## Tools and Technologies\n\n- **Python**: Core automation scripts\n- **Etsy API**: Listing and order management  \n- **Google Sheets API**: Inventory tracking\n- **Twilio**: SMS notifications for urgent issues\n- **Cron Jobs**: Scheduled tasks\n- **SQLite**: Local data storage and logging\n\n## Ethical Considerations\n\nAutomation in handmade businesses raises questions about authenticity. My approach:\n\n- **Transparency**: Customers know I'm a developer who uses tools\n- **Boundaries**: Only automate administrative tasks, never the craft itself\n- **Personal Touch**: Every item includes a handwritten thank-you note\n\n## Future Enhancements\n\n- **Machine Learning**: Demand forecasting for inventory planning\n- **Computer Vision**: Automated quality checking for consistent photos\n- **Voice Assistants**: Workshop inventory updates via voice commands\n\n## Open Source\n\nI've made sanitized versions of these tools available on GitHub. The handmade community benefits when we share efficiency improvements.\n\n*Interested in automating your creative business? Feel free to reach out with questions or share your own automation stories!*",
      "author": "Yuki Ainge",
      "publishedAt": "2024-02-05T16:00:00Z", 
      "updatedAt": "2024-02-05T16:00:00Z",
      "featured": false,
      "tags": ["python", "automation", "etsy", "e-commerce", "business"],
      "category": "Business",
      "readTime": "10 min read",
      "image": "/blog/etsy-automation.jpg"
    },
    {
      "id": "javascript-performance-tips",
      "title": "JavaScript Performance: Lessons from Building Real-Time LED Controllers",
      "slug": "javascript-performance-tips", 
      "excerpt": "Performance optimization techniques learned from building real-time web interfaces for LED installations. When 60fps isn't just nice-to-have, but essential.",
      "content": "# JavaScript Performance: Lessons from Building Real-Time LED Controllers\n\n*Published on February 12, 2024*\n\nBuilding web interfaces for LED installations taught me JavaScript performance lessons that apply far beyond hardware control. When you need consistent 60fps for thousands of LEDs, every millisecond matters.\n\n## The Performance Requirement\n\nLED installations demand real-time performance:\n- **60fps minimum**: Anything less creates visible flicker\n- **Low latency**: User interactions must feel immediate  \n- **Consistent timing**: Irregular frame rates break pattern synchronization\n- **Resource efficiency**: Often running on embedded hardware\n\n## Critical Optimizations\n\n### 1. Minimize Garbage Collection\n\n```javascript\n// Bad: Creates new objects every frame\nfunction updateLEDs(leds) {\n  return leds.map(led => {\n    return {\n      ...led,\n      color: calculateColor(led.position, Date.now())\n    }\n  })\n}\n\n// Good: Reuse objects, modify in place\nconst colorBuffer = new Float32Array(NUM_LEDS * 3)\n\nfunction updateLEDs(leds, timestamp) {\n  for (let i = 0; i < leds.length; i++) {\n    const colorIndex = i * 3\n    const color = calculateColor(leds[i].position, timestamp)\n    colorBuffer[colorIndex] = color.r\n    colorBuffer[colorIndex + 1] = color.g  \n    colorBuffer[colorIndex + 2] = color.b\n  }\n}\n```\n\n### 2. Efficient Animation Loops\n\n```javascript\n// Bad: Inconsistent timing, unnecessary work\nsetInterval(() => {\n  if (animationEnabled) {\n    updateFrame()\n    render()\n  }\n}, 16) // Roughly 60fps\n\n// Good: RequestAnimationFrame with delta timing\nlet lastTime = 0\nfunction animationLoop(currentTime) {\n  const deltaTime = currentTime - lastTime\n  lastTime = currentTime\n  \n  if (animationEnabled && deltaTime >= targetFrameTime) {\n    updateFrame(deltaTime)\n    render()\n  }\n  \n  requestAnimationFrame(animationLoop)\n}\n```\n\n### 3. Pre-calculate When Possible\n\n```javascript\n// Bad: Expensive calculations in render loop  \nfunction calculateWavePattern(x, y, time) {\n  return Math.sin(Math.sqrt(x*x + y*y) * 0.1 + time * 0.005) * 127 + 128\n}\n\n// Good: Pre-calculate lookup tables\nconst WAVE_TABLE_SIZE = 1024\nconst waveTable = new Float32Array(WAVE_TABLE_SIZE)\nfor (let i = 0; i < WAVE_TABLE_SIZE; i++) {\n  waveTable[i] = Math.sin(i / WAVE_TABLE_SIZE * Math.PI * 2)\n}\n\nfunction calculateWavePattern(x, y, time) {\n  const distance = Math.sqrt(x*x + y*y)\n  const waveIndex = Math.floor((distance * 0.1 + time * 0.005) * WAVE_TABLE_SIZE) % WAVE_TABLE_SIZE\n  return waveTable[waveIndex] * 127 + 128\n}\n```\n\n### 4. Batch DOM Operations\n\n```javascript\n// Bad: Multiple reflows\nfunction updateUI(data) {\n  data.forEach(item => {\n    document.getElementById(item.id).textContent = item.value\n    document.getElementById(item.id + '-bar').style.width = item.percentage + '%'\n  })\n}\n\n// Good: Batch with DocumentFragment\nfunction updateUI(data) {\n  const fragment = document.createDocumentFragment()\n  \n  data.forEach(item => {\n    const element = document.getElementById(item.id)\n    element.textContent = item.value\n    const bar = document.getElementById(item.id + '-bar')  \n    bar.style.width = item.percentage + '%'\n  })\n  \n  // Single reflow\n  document.body.appendChild(fragment)\n}\n```\n\n## Performance Monitoring\n\n### Custom Performance Metrics\n\n```javascript\nclass PerformanceMonitor {\n  constructor() {\n    this.frameCount = 0\n    this.totalFrameTime = 0\n    this.worstFrameTime = 0\n    this.lastReportTime = performance.now()\n  }\n  \n  startFrame() {\n    this.frameStartTime = performance.now()\n  }\n  \n  endFrame() {\n    const frameTime = performance.now() - this.frameStartTime\n    this.frameCount++\n    this.totalFrameTime += frameTime\n    this.worstFrameTime = Math.max(this.worstFrameTime, frameTime)\n    \n    if (this.frameCount % 60 === 0) {\n      this.reportMetrics()\n    }\n  }\n  \n  reportMetrics() {\n    const avgFrameTime = this.totalFrameTime / this.frameCount\n    const currentTime = performance.now()\n    const actualFPS = this.frameCount / ((currentTime - this.lastReportTime) / 1000)\n    \n    console.log({\n      fps: actualFPS.toFixed(1),\n      avgFrameTime: avgFrameTime.toFixed(2) + 'ms',\n      worstFrame: this.worstFrameTime.toFixed(2) + 'ms'\n    })\n    \n    // Reset for next measurement period\n    this.frameCount = 0\n    this.totalFrameTime = 0\n    this.worstFrameTime = 0\n    this.lastReportTime = currentTime\n  }\n}\n```\n\n## Real-World Impact\n\nThese optimizations enabled:\n- **Smooth 60fps** on Raspberry Pi hardware\n- **10,000+ LEDs** controlled simultaneously\n- **Sub-10ms latency** for user interactions\n- **Hours of operation** without memory leaks\n\n## Beyond LED Control\n\nThese techniques apply to many performance-critical scenarios:\n- **Data visualizations** with thousands of points\n- **Game development** requiring consistent frame rates\n- **Real-time dashboards** with frequent updates\n- **Mobile web apps** with limited resources\n\n## Profiling Tools\n\n### Essential Browser DevTools\n- **Performance tab**: Flame graphs show exactly where time is spent\n- **Memory tab**: Track garbage collection and memory leaks\n- **Rendering tab**: Visualize reflows and repaints\n\n### Custom Instrumentation\n```javascript\nfunction instrument(fn, name) {\n  return function(...args) {\n    const start = performance.now()\n    const result = fn.apply(this, args)\n    const end = performance.now()\n    \n    if (end - start > 5) { // Log slow operations\n      console.warn(`${name} took ${(end - start).toFixed(2)}ms`)\n    }\n    \n    return result\n  }\n}\n\n// Usage\nconst updateLEDs = instrument(originalUpdateLEDs, 'updateLEDs')\n```\n\n## Key Takeaways\n\n1. **Measure first**: Profile before optimizing\n2. **Garbage collection matters**: Object creation is expensive\n3. **Timing is everything**: Use proper animation loops\n4. **Pre-calculate when possible**: Move work out of hot paths\n5. **Batch operations**: Minimize browser reflows\n6. **Monitor continuously**: Performance can degrade over time\n\n*Working on performance-critical JavaScript? I'd love to hear about your optimization challenges and solutions!*",
      "author": "Yuki Ainge",
      "publishedAt": "2024-02-12T12:00:00Z",
      "updatedAt": "2024-02-12T12:00:00Z", 
      "featured": false,
      "tags": ["javascript", "performance", "optimization", "real-time", "hardware"],
      "category": "Programming",
      "readTime": "15 min read",
      "image": "/blog/javascript-performance.jpg"
    }
  ],
  "categories": [
    "Electronics",
    "Philosophy", 
    "Business",
    "Programming",
    "Craftsmanship",
    "Design"
  ],
  "tags": [
    "electronics",
    "arduino", 
    "flow-arts",
    "led",
    "programming",
    "woodworking",
    "craftsmanship",
    "philosophy",
    "process",
    "python",
    "automation",
    "etsy", 
    "e-commerce",
    "business",
    "javascript",
    "performance",
    "optimization",
    "real-time",
    "hardware",
    "design"
  ]
}